// oss/client-mobile/ios/OmniAuthModule.swift
import ExpoModulesCore
// The header generated by UniFFI
import omniauth_core 

public class OmniAuthModule: Module {
  // Keep Identity in memory (Native ARC handles lifecycle)
  private var activeIdentity: Identity? = nil

  public func definition() -> ModuleDefinition {
    Name("OmniAuth")

    // AsyncFunction is crucial for thread safety on iOS
    AsyncFunction("createVault") { (password: String) -> String in
      do {
        // Call Rust Constructor
        let vault = try Vault(masterPassword: password)
        self.activeIdentity = try vault.unlock()
        return "SUCCESS"
      } catch {
        throw Exception(name: "VaultCreationError", description: error.localizedDescription)
      }
    }

    Function("getPublicKey") { () -> String in
      guard let id = self.activeIdentity else {
        throw Exception(name: "VaultLocked", description: "Vault is not unlocked")
      }
      return id.getPublicSigningKey()
    }

    AsyncFunction("signChallenge") { (message: String) -> String in
      guard let id = self.activeIdentity else {
        throw Exception(name: "VaultLocked", description: "Vault is not unlocked")
      }
      // PQC Signing can be heavy, async prevents main thread block
      return id.signPayload(message: message)
    }

    Function("lock") {
      self.activeIdentity = nil // ARC will deallocate, triggering Rust Drop/Zeroize
    }
  }
}
