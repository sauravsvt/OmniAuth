package crypto

import (
	"encoding/base64"
	"encoding/json"
	"os"
	"testing"

	"github.com/cloudflare/circl/sign/mldsa/mldsa65"
)

type InteropVector struct {
	Msg string `json:"msg"`
	Pk  string `json:"pk"`
	Sig string `json:"sig"`
}

func TestRustInterop(t *testing.T) {
	// Read the vector file generated by Rust
	data, err := os.ReadFile("interop_vectors.json") // Assumes run from proprietary/backend or adjust path
	if err != nil {
		// If file not found, we skip, OR we assume we are running from backend root
		// Let's try to handle relative path: current dir for go test ./... is the package dir?
		// proprietary/backend/internal/crypto
		// The file is in proprietary/backend/interop_vectors.json
		data, err = os.ReadFile("../../interop_vectors.json")
		if err != nil {
			t.Fatalf("Failed to read interop vectors: %v. Did you run 'cargo test -- --ignored' in crypto-core?", err)
		}
	}

	var v InteropVector
	if err := json.Unmarshal(data, &v); err != nil {
		t.Fatalf("Failed to parse vector json: %v", err)
	}

	// Decode Base64
	msg := []byte(v.Msg)

	// Rust uses standard base64
	pkBytes, err := base64.StdEncoding.DecodeString(v.Pk)
	if err != nil {
		t.Fatalf("Invalid PK base64: %v", err)
	}

	sigBytes, err := base64.StdEncoding.DecodeString(v.Sig)
	if err != nil {
		t.Fatalf("Invalid Sig base64: %v", err)
	}

	t.Logf("PK Length: %d (Expected 1952)", len(pkBytes))
	t.Logf("Sig Length: %d (Expected 3309 for ML-DSA-65)", len(sigBytes))

	// Load Public Key
	// Rust pqcrypto-dilithium 0.5 seems to use FIPS 204 (ML-DSA-65) parameters
	var pk mldsa65.PublicKey
	if err := pk.UnmarshalBinary(pkBytes); err != nil {
		t.Fatalf("Failed to unpack PK: %v", err)
	}

	// Verify
	if !mldsa65.Verify(&pk, msg, []byte{}, sigBytes) {
		t.Fatal("Rust signature failed verification (ML-DSA-65)!")
	}

	t.Logf("Success! Verified Rust signature for message: %s", v.Msg)
}
